import { Callout } from 'nextra-theme-docs'
import Image from '../components/Image';
import PkgManagerTabs from '../components/PkgManagerTabs'
import ProjectTypeTabs from '../components/ProjectTypeTabs'
import PkgManagerChildren from '../components/PkgManagerChildren'
import TokenLinkCode from '../components/TokenLinkCode'

# Getting Started

Haetae is **incremental** task runner.<br/>
The task can be test, lint, build, or anything.
It can be used in any project, no matter what language, framework, test runner, linter/formatter, build system, or CI you use.<br/>

For now, in this *Getting Started* article, we are starting from an example of incremental testing.

## Why?

Let's say you're building a calculator project, named *'my-calculator'*.

```fish copy filename="Your Project"
# Entrypoint (index.js) is omitted for brevity
my-calculator
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ add.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ exponent.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ multiply.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ subtract.js
‚îî‚îÄ‚îÄ test
    ‚îú‚îÄ‚îÄ add.test.js
    ‚îú‚îÄ‚îÄ exponent.test.js
    ‚îú‚îÄ‚îÄ multiply.test.js
    ‚îî‚îÄ‚îÄ subtract.test.js
```

The dependency graph is like this.

<Image src="/getting-started/dependency-graph.svg" alt="Dependeny graph of 'my-calculator'"/>

*`exponent.js`* depends on *`multiply.js`*, which depends on *`add.js`* and so on.

When testing, we should take the dependency graph into account.<br/>
We do NOT have to test all files (*`*.test.js`*) for every single tiny change <small>(Waste of your CI resources and time)</small>.<br/>
Rather, **we should do it incrementally, which means testing only files affected by the changes.**

For example, when *`multiply.js`* is changed, test only *`exponent.test.js`* and *`multiply.test.js`*.<br/>
When *`add.js`* is changed, test all files (<small>*`exponent.test.js`*, *`multiply.test.js`*, *`subtract.test.js`* and *`add.test.js`*</small>).<br/>
When test file <small>(e.g. *`add.test.js`*)</small> is changed, then just execute the test file itself <small>(e.g. *`add.test.js`*)</small>.

Then how can we do it, automatically?<br/>
Here's where **Haetae** comes in.<br/>
By just a simple config, Haetae can automatically detect the dependency graph and test only affected files.<br/>
<small>(In this article, [Jest](https://jestjs.io) is used just as an example. You can use any test runner. )</small>

## Installation

So, let's install Haetae. (<small>Node 20 or higher is required.</small>)<br/>
It doesn't matter whether your project is new or existing <small>(Haetae can be progressively adapted)</small>.<br/>
It's good for monorepo as well. <small>(Guided later in other part of docs.)</small><br/>
Literally **any project** is proper.

<br/>

<PkgManagerTabs>
<>
```bash copy filename="Installation"
npm install --save-dev haetae
```

```bash copy filename="Execution"
npx haetae --help

# `ht` is shorthand for `haetae`
npx ht --help
```
</>
<>
```bash copy filename="Installation"
yarn add --dev haetae
```

```bash copy filename="Execution"
yarn haetae --help

# `ht` is shorthand for `haetae`
yarn ht --help
```
</>
<>
```bash copy filename="Installation"
pnpm add --save-dev haetae
```

```bash copy filename="Execution"
pnpm haetae --help

# `ht` is shorthand for `haetae`
pnpm ht --help
```
</>
</PkgManagerTabs>

<Callout>
  **Are you developing a library (e.g. plugin) for Haetae?** <br/>
  You can depend on [`@haetae/core{:ts}`](apis/core), [`@haetae/utils{:ts}`](apis/utils),
  [`@haetae/git{:ts}`](apis/git), [`@haetae/javascript{:ts}`](apis/javascript),
  [`@haetae/cli{:ts}`](apis/cli) independently. Note that the package [`haetae{:ts}`](apis/haetae)
  includes all of them.
</Callout>

## Basic configuration

Now, we are ready to configure Haetae.<br/>
Let's create a config file.
Its name and execution setting are different depending on whether your project is ESM/CJS, or JS/TypeScript.

<Callout>
  **CJS/ESM** <br/>
  Haetae supports both CJS and ESM project. <br/>
  Haetae itself is written in ESM, but it can be used for CJS projects as well, as long as the config file is ESM.
</Callout>

<br/>

<ProjectTypeTabs>
<>
If your *`package.json`* is configured as ESM,
name the config file *`haetae.config.js`*.

```fish copy filename="Your Project" {2}
my-calculator
‚îú‚îÄ‚îÄ haetae.config.js # <--- Haetae config file
‚îú‚îÄ‚îÄ package.json # <--- "type": "module"
‚îú‚îÄ‚îÄ src/ # contents are omitted for brevity
‚îî‚îÄ‚îÄ test/ # contents are omitted for brevity
```
</>
<>
If your *`package.json`* is configured as CJS,
name the config file *`haetae.config.mjs`*.

```fish copy filename="Your Project" {2}
my-calculator
‚îú‚îÄ‚îÄ haetae.config.mjs # <--- Haetae config file
‚îú‚îÄ‚îÄ package.json # <--- "type": "commonjs" or "type" is omitted
‚îú‚îÄ‚îÄ src/ # contents are omitted for brevity
‚îî‚îÄ‚îÄ test/ # contents are omitted for brevity
```
</>
<>
Note that you can still name it *`haetae.config.js`*.
But you may want to write the config in TypeScript.

If your *`package.json`* and *`tsconfig.json`* are configured as ESM,
name the config file *`haetae.config.ts`*.


```fish copy filename="Your Project" {2}
my-calculator
‚îú‚îÄ‚îÄ haetae.config.ts # <--- Haetae config file
‚îú‚îÄ‚îÄ package.json # <--- "type": "module"
‚îú‚îÄ‚îÄ tsconfig.json # <--- "module": "node16" or "es6" or ... and so on
‚îú‚îÄ‚îÄ src/ # contents are omitted for brevity
‚îî‚îÄ‚îÄ test/ # contents are omitted for brevity
```

Next, install [`ts-node`](https://www.npmjs.com/package/ts-node).
It's optional `peerDependencies` of [`@haetae/core{:ts}`](./apis/core), which is an internal dependency of `haetae`.

<PkgManagerChildren>
```bash copy filename="Terminal"
npm install --save-dev ts-node
```
```bash copy filename="Terminal"
yarn add --dev ts-node
```
```bash copy filename="Terminal"
pnpm add --save-dev ts-node
```
</PkgManagerChildren>

Finally, provide an environment variable [`$NODE_OPTIONS`](https://nodejs.org/api/cli.html#node_optionsoptions).

```bash copy filename="Terminal"
NODE_OPTIONS='--loader=ts-node/esm' haetae --help
```

Registering scripts in *`package.json`* is a recommended good practice.

```json copy filename="package.json"
{
  "scripts": {
    "haetae": "cross-env NODE_OPTIONS='--loader=ts-node/esm' haetae",
    // or
    "ht": "cross-env NODE_OPTIONS='--loader=ts-node/esm' haetae"
  }
}
```
</>
<>

Note that you can still name it *`haetae.config.mjs`*.
But you may want to write the config in TypeScript.

If your *`package.json`* and *`tsconfig.json`* are configured as CJS,
name the config file *`haetae.config.mts`*.

```fish copy filename="Your Project" {2}
my-calculator
‚îú‚îÄ‚îÄ haetae.config.mts # <--- Haetae config file
‚îú‚îÄ‚îÄ package.json # <--- "type": "commonjs" or "type" is omitted
‚îú‚îÄ‚îÄ tsconfig.json # <--- "module": "commonjs"
‚îú‚îÄ‚îÄ src/ # contents are omitted for brevity
‚îî‚îÄ‚îÄ test/ # contents are omitted for brevity
```

Next, install [`ts-node`](https://www.npmjs.com/package/ts-node).
It's optional `peerDependencies` of [`@haetae/core{:ts}`](./apis/core), which is an internal dependency of [`haetae{:ts}`](./apis/haetae).

<PkgManagerChildren>
```bash copy filename="Terminal"
npm install --save-dev ts-node
```
```bash copy filename="Terminal"
yarn add --dev ts-node
```
```bash copy filename="Terminal"
pnpm add --save-dev ts-node
```
</PkgManagerChildren>

Finally, provide environment variables [`$TS_NODE_COMPILER_OPTIONS`](https://typestrong.org/ts-node/docs/options/#compileroptions)
 and [`$NODE_OPTIONS`](https://nodejs.org/api/cli.html#node_optionsoptions).
Because your *`tsconfig.json`* is CJS, `$TS_NODE_COMPILER_OPTIONS` makes sure haetae's config file is ESM.

```bash copy filename="Terminal"
# Instead of 'node16', you can choose other values like 'nodenext', etc.
TS_NODE_COMPILER_OPTIONS='{"module": "node16", "moduleResolution": "node16"}' \
NODE_OPTIONS='--loader=ts-node/esm' \
haetae --help
```

Registering scripts in *`package.json`* is a recommended good practice.

```json copy filename="package.json"
{
  "scripts": {
    "haetae": "cross-env TS_NODE_COMPILER_OPTIONS='{\"module\": \"node16\", \"moduleResolution\": \"node16\"}' NODE_OPTIONS='--loader=ts-node/esm' haetae",
    // or
    "ht": "cross-env TS_NODE_COMPILER_OPTIONS='{\"module\": \"node16\", \"moduleResolution\": \"node16\"}' NODE_OPTIONS='--loader=ts-node/esm' haetae"
  }
}
```

Or you can create a dedicated tsconfig for Haetae.

```fish copy filename="Your Project" {4}
my-calculator
‚îú‚îÄ‚îÄ haetae.config.mts # <--- Haetae config file
‚îú‚îÄ‚îÄ package.json # <--- "type": "commonjs" or "type" is omitted
‚îú‚îÄ‚îÄ tsconfig.haetae.json # <--- "module": "node16" or "es6" or ... and so on
‚îú‚îÄ‚îÄ tsconfig.json # <--- "module": "commonjs"
‚îú‚îÄ‚îÄ src/ # contents are omitted for brevity
‚îî‚îÄ‚îÄ test/ # contents are omitted for brevity
```

Then, provide an environment variable [`$TS_NODE_PROJECT`](https://typestrong.org/ts-node/docs/options/#project)
instead of [`$TS_NODE_COMPILER_OPTIONS`](https://typestrong.org/ts-node/docs/options/#compileroptions).

```json copy filename="package.json"
{
  "scripts": {
    "haetae": "cross-env TS_NODE_PROJECT=tsconfig.haetae.json NODE_OPTIONS='--loader=ts-node/esm' haetae",
    // or
    "ht": "cross-env TS_NODE_PROJECT=tsconfig.haetae.json NODE_OPTIONS='--loader=ts-node/esm' haetae"
  }
}
```
</>
</ProjectTypeTabs>

<Callout>
  **Config Filename** <br/>
  Haetae tries to find `haetae.config.{js,mjs,ts,mts}` by default.
  You can explicitly specify an arbitrary file with [`-c, --config`](./cli#-c---config) option.
</Callout>

Before we start, check if you initialized git.
Haetae can be used with any other version control systems, but using git is assumed in this article.

We can write down the config file like this.<br/>

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/git#changedfiles',
  '.dependOn': './apis/javascript#dependon',
}}>
```js copy filename="haetae.config.js" showLineNumbers
import { $, configure, git, utils, js } from 'haetae'

export default configure({
  // Other options are omitted for brevity.
  commands: {
    myTest: {
      run: async () => {
        // An array of changed files
        const changedFiles = await git.changedFiles()
        // An array of test files that (transitively) depend on changed files
        const affectedTestFiles = await js.dependOn({
          dependents: ['**/*.test.js'], // glob pattern
          dependencies: changedFiles,
        })

        if (affectedTestFiles.length) {
          // Equals to "pnpm jest /path/to/foo.test.ts /path/to/bar.test.ts ..."
          // Change 'pnpm jest' to your test runner.
          await $`pnpm jest ${affectedTestFiles}`
        }
      },
    },
  },
})
```
</TokenLinkCode>

Multiple APIs are used in the config file above.<br/>
They all have various options <small>(Check out API docs)</small>.
But we are going to use their sensible defaults for now.<br/>

The [Tagged Template Literal](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
[`${:ts}`](./apis/haetae#dollar) on line number 19 can run arbitrary shell commands.
It is [execa](https://github.com/sindresorhus/execa)'s [`$` function](https://github.com/sindresorhus/execa#command),
and haetae preconfigured its `cwd` as haetae config file's directory, and [`stdio`](affectedTestFiles) as `'inherit'`, all of which you can override of course.
If it receives a placeholder (e.g. `${affectedTestFiles}`) being an array, it automatically joins a whitespace (`' '`) between elements.
It has other traits and options as well. Check out `execa`'s API docs for more detail.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
}}>
```js copy
import { $ } from 'haetae'

// The following two lines of code have same effects respectively
await $`pnpm jest ${affectedTestFiles}`
await $`pnpm jest ${affectedTestFiles.join(' ')}`
```
</TokenLinkCode>

<Callout>
**Credit to `google/zx`**<br/>
`$` as a Tagged Template Literal is first inspired by [`google/zx`](https://github.com/google/zx). Thanks!
</Callout>

Then run `haetae` like below.

```fish copy filename="Terminal"
haetae myTest
```
<small>(Unless you installed `haetae` globally, you should execute it through package manager (e.g. `pnpm haetae myTest`))</small>

Note that `myTest` in the command above is the name of the command we defined in the config file.
You can name it whatever you want. And as you might guess, you can define multiple commands
(e.g. `myLint`, `myBuild`, `myIntegrationTest`, etc) in the config file.<br/>

It will print the result like this.

```fish copy filename="Terminal"
‚úî  success   Command myTest is successfully executed.

‚é° üïó time: 2023 May 28 11:06:06 Asia/Seoul 1(timestamp: 1685239566483)
‚éú üå± env: {}
‚éú #Ô∏è‚É£ envHash: bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f
‚éú üíæ data:
‚éú      "@haetae/git":
‚éú        commit: 979f3c6bcafe9f0b81611139823382d615f415fd
‚éú        branch: main
‚é£        specVersion: 1
```

As this is the first time of running the command `haetae myTest`,
[`git.changedFiles(){:ts}`](./apis/git#changedfiles) in the config returns every file tracked by git in your project as changed files
<small>(There are [options](./apis/git#changedfiles). Check out API docs after reading this article)</small>.
This behavior results in running all of the tests.<br/>

[`js.dependOn(){:ts}`](./apis/javascript#dependon) understands direct or transitive dependencies between files,
 by parsing `import` or `require()`, etc.
So it can be used to detect which test files (transitively) depend on at least one of the changed files.<br/>

<Callout>
**`js.dependOn` can detect multiple formats**<br/>
ES6+, CJS, TypeScript, JSX, Webpack, CSS Preprocessors(Sass, Scss, Stylus, Less), PostCSS are supported.
For node, [Subpath Imports](https://nodejs.org/api/packages.html#subpath-imports) and [Subpath Exports](https://nodejs.org/api/packages.html#subpath-exports) are also supported.
For TypeScript, [Path Mapping](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) is also supported.
If you use Typescript or Webpack, check out [the API docs](./apis/javascript#dependon) and pass additional options like `options.tsConfig{:ts}` and/or `options.webpackConfig{:ts}`.
</Callout>

<Callout>
**`js.dependOn`** vs **`js.dependsOn`** vs **`utils.dependOn`** vs **`utils.dependsOn`** <br/>
There are severel APIs of simliar purposes.
- [`js.dependOn{:ts}`](./apis/javascript#dependon) : For multiple dependents. On js ecosystem.
- [`js.dependsOn{:ts}`](./apis/javascript#dependson) : For a single dependent. On js ecosystem.
- [`utils.dependOn{:ts}`](./apis/utils#dependon) : For multiple dependents. General-purpose.
- [`utils.dependsOn{:ts}`](./apis/utils#dependson) : For a single dependent. General-purpose.

Check out the API docs later for more detail.
</Callout>

Note that it cannot parse dynamic imports (`import(){:ts}`).
Dynamic or extra dependencies can be specified as `additionalGraph` option, explained later in this article.

```fish copy filename="Your Project" {2}
my-calculator
‚îú‚îÄ‚îÄ .haetae/store.json # <--- Generated. Haetae store file
‚îú‚îÄ‚îÄ haetae.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îî‚îÄ‚îÄ test
```

May you have noticed, the store file *`.haetae/store.json`* is generated.
It stores histories of Haetae executions, which makes incremental tasks possible.
For example, the commit ID `979f3c6` printed from our first execution example above is the current git HEAD `haetae myTest` ran on.
This information is logged in the store file to be used later.

## Detecting the last commit Haetae ran on successfully

Let's say we made some changes and added 2 commits.

<Image src="/getting-started/commit-history.svg" alt="Commit history after the first running of Haetae"/>

`979f3c6` is the last commit Haetae ran on successfully.<br/>
`0c3b3cc` and `1d17a2f` are new commits after that.<br/>
What will happen when we run Haetae again?

```fish copy filename="Terminal"
haetae myTest
```

This time, only *`exponent.test.js`* and *`multiply.test.js`* are executed.
That's because [`git.changedFiles(){:ts}`](./apis/git#changedfiles) automatically
returns only the files changed since the last successful execution of Haetae.

For another example, if you modify `add.js`, then all tests will be executed,
because [`js.dependOn(){:ts}`](./apis/javascript#dependon) **detects dependency transitively**.

If you modify `add.test.js`, only the test file itself `add.test.js` will be executed,
as **every file is treated as depending on itself.**

```fish copy filename="Terminal"
‚úî  success   Command myTest is successfully executed.

‚é° üïó time: 2023 May 28 19:03:25 Asia/Seoul (timestamp: 1685268205443)
‚éú üå± env: {}
‚éú #Ô∏è‚É£ envHash: bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f
‚éú üíæ data:
‚éú      "@haetae/git":
‚éú        commit: 1d17a2f2d75e2ac94f31e53376c549751dca85fb
‚éú        branch: main
‚é£        specVersion: 1
```

Accordingly, the new commit `1d17a2f` is logged in the store file.<br/>

The output above is an example of successful task.
Conversely, if the test fails, `pnpm jest <...>`, which we gave to [`${:ts}`](./apis/haetae#dollar)
in the config, exits with non-zero exit code.
This lets [`${:ts}`](./apis/haetae#dollar) throws an error.
So `myTest.run(){:ts}` is not completed successfully, causing the store file is not renewed.<br/>

This behavior is useful for incremental tasks.
The failed test (or any incremental task) will be re-executed later again until the problem is fixed.

<Callout>
**`stdio`** and/or **`reject`**<br/>
<TokenLinkCode tokens={{
  'stdio': 'https://github.com/sindresorhus/execa#stdio',
  'reject': 'https://github.com/sindresorhus/execa#reject',
}} inline>`{ stdio: 'inherit', reject: true /*, and more */ }{:ts}`</TokenLinkCode> is default options for [`${:ts}`](./apis/haetae#dollar).
This makes `Promise` rejected when [failed](https://github.com/sindresorhus/execa#childprocessresult) (e.g. non-zero exit code).
If you set `stdio` or `reject` differently, it may not automatically be rejected when failed.
So you should manually make sure whether to throw an error.
For example, when `stdio` is set to `'pipe'`, assert [`failed`](https://github.com/sindresorhus/execa#failed) and/or [`stderr`](https://github.com/sindresorhus/execa#stderr) properties by yourself.
</Callout>

## `env` configuration

Sometimes we need to separate several environments.<br/>

### Simple environment variable example

For example, logic of your project might act differently depending on the environment variable `$NODE_ENV`.
So, the history of an incremental task also should be recorded for each environment in a separated manner.
Let's add `env` to the config file to achieve this.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
}}>
```js copy filename="haetae.config.js" {6-8}
import { configure } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { // <--- Add this
        NODE_ENV: process.env.NODE_ENV,
      },
      run: async () => { /* ... */ },
    },
  },
})
```
</TokenLinkCode>

The key name `NODE_ENV` is just an example. You can name it as you want.<br/>

From now on, the store file will manage the history of each environment separately.
For example, if `$NODE_ENV` can have two values, `'development'` or `'production'`,
then Haetae will manage two incremental histories for each environment.

You don't have to care about the past history of `myTest` executed without `env`.
When a command is configured without `env`, it's treated as if configured with `env: {}`, which is totally fine.
So there will be 3 `env`s to be recorded in the store file:

* `{}`
* `{ NODE_ENV: 'production' }{:ts}`
* `{ NODE_ENV: 'development' }{:ts}`

Though we changed the schema of `env` in the config from `{}` to `{ NODE_ENV: 'development' | 'production' }{:ts}`,
the history of `env: {}` already recorded in the store file is NOT automatically deleted.
It just stays in the store file.
This behavior is safe because incremental histories are managed **per env**. So don't worry about the past's vestige.
If you care about disk space, configuring the auto-removal of some obsolete history is guided later in this article.

### Multiple keys

You can add more keys in `env` object.<br/>
For instance, let's change the config to this.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  'pkg': './apis/haetae#pkg',
  '.hash': './apis/utils#hash',
  '.majorVersion': './apis/javascript#majorversion',
  '.branch': './apis/git#branch',
}}>
```js copy filename="haetae.config.js" showLineNumbers
import assert from 'node:assert/strict' // `node:` protocol is optional
import { configure, git, js, utils, pkg } from 'haetae'
import semver from 'semver'

export default configure({
  commands: {
    myTest: {
      env: async () => { // <--- Changed to async function from object
        assert(['development', 'production'].includes(process.env.NODE_ENV))
        return {
          NODE_ENV: process.env.NODE_ENV,
          jestConfig: await utils.hash(['jest.config.js']),
          jest: await js.majorVersion('jest'),
          branch: await git.branch(),
          os: process.platform,
          node: semver.major(process.version),
          haetae: pkg.version.major,
        }
      },
      run: async () => { /* ... */ },
    },
  },
})
```
</TokenLinkCode>

The object has more keys than before, named `jestConfig`, `jest`, `branch` and so on.
In this example, if any of `$NODE_ENV`, Jest config file, major version of Jest, git branch, OS platform, major version of Node.js,
or major version of the package `haetae` is changed, it's treated as a different environment.

And now `env` becomes a function. You can even freely write any additional code in it,
like assertion (`assert(){:ts}`) in line number 9 above. `myTest.env(){:ts}` is executed before `myTest.run(){:ts}`.
When an error is thrown in `myTest.env(){:ts}`, `myTest.run(){:ts}` is not executed, and the store file is not renewed.
This is intended design for incremental tasks.

If you just want to evaluate the value `env` function returns, you can use [`-e, --env`](./cli#-e---env) option.
This does not modify the store, but just prints out to the console.

```fish copy filename="Terminal"
$ haetae myTest --env

‚úî  success   Current environment is successfully evaluated for the command myTest

‚é° env:
‚éú   NODE_ENV: development
‚éú   jestConfig: 642645d6bc72ab14a26eeae881a0fc58e0fb4a25af31e55aa9b0d134160436eb
‚éú   jest: 29
‚éú   branch: main
‚éú   os: darwin
‚éú   node: 18
‚éú   haetae: 0
‚é£ envHash: 203ceac1714279231e82d91614f2ebe50f5b1a7a
```

## Additional dependency graph

Until now, [`js.dependOn(){:ts}`](./apis/javascript#dependon) is used for automatic detection of dependency graph.
But sometimes, you need to specify some dependencies manually.<br/>

### Simple integration test

For example, let's say you're developing a project communicating with a database.

```fish copy filename="Your Project"
your-project
‚îú‚îÄ‚îÄ haetae.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ external.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logic.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ test
    ‚îú‚îÄ‚îÄ data.sql
    ‚îú‚îÄ‚îÄ external.test.js
    ‚îú‚îÄ‚îÄ logic.test.js
    ‚îî‚îÄ‚îÄ index.test.js
```

The explicit dependency graph is like this.<br/>
*`logic.js`* contains business logic, including communicating with a database.<br/>
*`external.js`* communicates with a certain external service, regardless of the database.

<Image src="/getting-started/dependency-graph-with-sql.svg" alt="Dependency graph"/>

But there is an SQL file named *`data.sql`* for an integration test.
It's not (can't be) imported (e.g. `import`, `require()`) by any source code file obviously.

Let Haetae think *`logic.js`* depends on *`data.sql`*, by `additionalGraph`.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/git#changedfiles',
  '.graph': './apis/utils#graph',
  '.dependOn': './apis/javascript#dependon',
}}>
```js copy filename="haetae.config.js" {10-17,21}
import { $, configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        // A graph of additional dependencies specified manually
        const additionalGraph = await utils.graph({
          edges: [
            {
              dependents: ['src/logic.js'],
              dependencies: ['test/data.sql'],
            },
          ],
        })
        const affectedTestFiles = await js.dependOn({
          dependents: ['**/*.test.js'],
          dependencies: changedFiles,
          additionalGraph, // <--- New option
        })
        if (affectedTestFiles.length) {
          await $`pnpm jest ${affectedTestFiles}`
        }
      },
    },
  },
})
```
</TokenLinkCode>

Then the implicit dependency graph becomes explicit.

<Image src="/getting-started/dependency-graph-with-sql-focus.svg" alt="Dependency graph with .env"/>

From now on, when the file *`data.sql`* is changed, *`index.test.js`* and *`logic.test.js`*. are executed.
As *`external.test.js`* doesn't transitively depend on *`data.sql`*, it's not executed.

Unlike this general and natural flow, if you decide that *`index.test.js`* should never be affected by *`data.sql`*,
you can change the config.

<TokenLinkCode tokens={{
  '.graph': './apis/utils#graph',
}}>
```js copy filename="haetae.config.js" {5,}
// Other content is omitted for brevity
const additionalGraph = await utils.graph({
  edges: [
    {
      dependents: ['test/logic.test.js'], // 'src/logic.js' to 'test/logic.test.js'
      dependencies: ['test/data.sql'],
    },
  ],
})
```
</TokenLinkCode>

By this, *`data.sql`* doesn't affect *`index.test.js`* anymore.<br/>
But I recommend this practice only when you're firmly sure that *`index.test.js`* will not be related to *`data.sql`*.
Because, otherwise, you should update the config again when the relation is changed.

### `env` vs `additionalGraph`

The effect of `addtionalGraph` is different from `env`.
`env` is like defining parallel universes, where history is recorded separately.

If you place *`data.sql`* in `env` (e.g. with [`utils.hash(){:ts}`](./apis/utils#hash)) instead of `additonalGraph`,
every test file will be executed when *`data.sql`* changes,
unless the change is a rollback to past content which can be matched with a past value of `env` logged in the store file (*`.haetae/store.json`*).

*`external.js`* and *`external.test.js`* are regardless of database.
That's why *`data.sql`* is applied as `addtionalGraph`, not as `env`.

But that's case by case. In many situations, `env` is beneficial.

1. If *`data.sql`* affects 'most' of your integration test files,

or

2. If which test file does and doesn't depend on *`data.sql`* is not clear or the relations change frequently,

or

3. If *`data.sql`* is not frequently changed,

then `env` is a good place.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  '.hash': './apis/utils#hash',
}}>
```js copy filename="haetae.config.js" {7}
import { configure, utils } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: async () => ({
        testData: await utils.hash(['test/data.sql']),
      }),
      run: async () => { /* ... */ }, // without `additionalGraph`
    },
  },
})
```
</TokenLinkCode>

### Cartesian product

You can specify the dependency graph from a chunk of files to another chunk.

<TokenLinkCode tokens={{
  '.graph': './apis/utils#graph',
}}>
```js copy filename="haetae.config.js"
// Other content is omitted for brevity
const additionalGraph = await utils.graph({
  edges: [
    {
      dependents: ['test/db/*.test.js'],
      dependencies: [
        'test/docker-compose.yml',
        'test/db/*.sql',
      ],
    },
  ],
})
```
</TokenLinkCode>

This means that any test file under *`test/db/`* depends on any SQL file under *`test/db/`* and *`test/docker-compose.yml`*.

<Image src="/getting-started/additional-dependency-graph-cartesian-product.svg" alt="Additional Dependency Graph Cartesian Product"/>

### Distributed notation

You don't have to specify a dependent's dependencies all at once.
It can be done in a distributed manner.

<TokenLinkCode tokens={{
  '.graph': './apis/utils#graph',
}}>
```js copy filename="haetae.config.js" showLineNumbers
// Other content is omitted for brevity
const additionalGraph = await utils.graph({
  edges: [
    {
      dependents: ['foo', 'bar'],
      dependencies: ['one', 'two'],
    },
    {
      dependents: ['foo', 'qux'], // 'foo' appears again, and it's fine
      dependencies: ['two', 'three', 'bar'], // 'two' and 'bar' appear again, and it's fine
    },
    {
      dependents: ['one', 'two', 'three'],
      dependencies: ['two'], // 'two' depends on itself, and it's fine
    },
    {
      dependents: ['foo'],
      dependencies: ['one'], // 'foo' -> 'one' appears again, and it's fine
    },
  ],
})
```
</TokenLinkCode>

On line number 13-14, we marked *`two`* depending on *`two`* itself.
That's OK, as every file is treated as depending on itself.
So *`foo`* depends on *`foo`*. *`bar`* also depends on *`bar`*, and so on.

<Image src="/getting-started/additional-dependency-graph-distributed-notation.svg" alt="Additional Dependency Graph Distributed Notation"/>

### Circular dependency

Haetae supports circular dependency as well.
Although circular dependency is, in general, considered not a good practice,
it's fully up to you to decide whether to define it.
Haetae does not prevent you from defining it.

<TokenLinkCode tokens={{
  '.graph': './apis/utils#graph',
}}>
```js copy filename="haetae.config.js"
// Other content is omitted for brevity
const additionalGraph = await utils.graph({
  edges: [
    {
      dependents: ['index.js'],
      dependencies: ['foo'],
    },
    {
      dependents: ['foo'],
      dependencies: ['bar'],
    },
    {
      dependents: ['bar'],
      dependencies: ['index.js'],
    },
  ],
})
```
</TokenLinkCode>

<Image src="/getting-started/circular-dependency-graph.svg" alt="Circular dependency graph"/>

Assume the relations between *`index.js`*, *`foo`*, and *`bar`* are given by `additionalGraph`,
and the rests are automatically detected.

In this situation, *`index.test.js`* is executed when any of files, except *`utils.test.js`*, are changed, including *`foo`*, and *`bar`*.<br/>
On the other hand, *`utils.test.js`* is executed only when *`utils.js`* or *`utils.test.js`* itself is changed.

<Callout>
  **More APIs not covered** <br/>
  There're more APIs related to dependency graph, like
  [`js.graph{:ts}`](./apis/javascript#graph),
  [`js.deps{:ts}`](./apis/javascript#deps),
  [`utils.deps{:ts}`](./apis/utils#deps),
  [`utils.mergeGraph{:ts}`](./apis/utils#mergegraph), etc.
  This article doesn't cover them all. Check out the API docs for more detail.
</Callout>

## Record Data

Haetae has a concept of *'Record'* (type: [`core.HaetaeRecord`](./apis/core#haetaerecord))
and *'Record Data'* (type: `core.HaetaeRecord.data{:ts}`).

In the previous sections, we've already seen terminal outputs like this.

```fish copy filename="Terminal"
$ haetae myTest

‚úî  success   Command myTest is successfully executed.

‚é° üïó time: 2023 May 28 11:06:06 Asia/Seoul (timestamp: 1685239566483)
‚éú üå± env: {}
‚éú #Ô∏è‚É£ envHash: bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f
‚éú üíæ data:
‚éú      "@haetae/git":
‚éú        commit: 979f3c6bcafe9f0b81611139823382d615f415fd
‚éú        branch: main
‚é£        specVersion: 1
```

This information is logged in the store file (*`.haetae/store.json`*), and called *'Record'*.
The `data` field is called *'Record Data'*.
Let's check them out.

```fish copy filename="Terminal"
cat .haetae/store.json
```


The output is like this.

```json filename="Terminal" {13,25-27,39-41,53-60,72-74}
{
  "specVersion": 1,
  "commands": {
    "myTest": [
      {
        "data": {
          "@haetae/git": {
            "commit": "1d17a2f2d75e2ac94f31e53376c549751dca85fb",
            "branch": "main",
            "specVersion": 1
          }
        },
        "env": {},
        "envHash": "bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f",
        "time": 1685239566483
      },
      {
        "data": {
          "@haetae/git": {
            "commit": "a4f4e7e83eedbf2269fbf29d91f08289bdeece91",
            "branch": "main",
            "specVersion": 1
          }
        },
        "env": {
          "NODE_ENV": "production"
        },
        "envHash": "4ed28f8415aeb22c021e588c70d821cb604c7ae0",
        "time": 1685458529856
      },
      {
        "data": {
          "@haetae/git": {
            "commit": "442fefc582889bdaee5ec2bd8b74804680fc30ee",
            "branch": "main",
            "specVersion": 1
          }
        },
        "env": {
          "NODE_ENV": "development"
        },
        "envHash": "2b580e42012efb489cdea43194c9dd6aed6b77d8",
        "time": 1685452061199
      },
      {
        "data": {
          "@haetae/git": {
            "commit": "ef3fdf88e9fad90396080335096a88633fbe893f",
            "branch": "main",
            "specVersion": 1
          }
        },
        "env": {
          "jestConfig": "642645d6bc72ab14a26eeae881a0fc58e0fb4a25af31e55aa9b0d134160436eb",
          "jest": 29,
          "branch": "main",
          "os": "darwin",
          "node": 18,
          "haetae": 0
        },
        "envHash": "62517924fb2c6adb38b4f30ba75a513066f5ac80",
        "time": 1685455507556
      },
      {
        "data": {
          "@haetae/git": {
            "commit": "7e3b332f0657272cb277c312ff25d4e1145f895c",
            "branch": "main",
            "specVersion": 1
          }
        },
        "env": {
          "testData": "b87b8be8df58976ee7da391635a7f45d8dc808357ff63fdcda699df937910227"
        },
        "envHash": "7ea1923c8bad940a97e1347ab85abd4811e82531",
        "time": 1685451151035
      }
    ]
  }
}

```

<Callout>
**Env Hash** <br/>
The field `envHash` is **SHA-1** of `env` object.
The `env` object is serialized by a deterministic method no matter how deep it is, and calculated as a hash.
The hash is used to match the current `env` with previous records.
**SHA-1** is considered insecure to hide information, but good enough to prevent collision for history comparison.
For example, `git` also uses **SHA-1** as a commit ID.
When your *Env* or *Record Data* contains a confidential field and you're worrying what if the store is leaked,
you can preprocess secret fields with a stronger cryptographic hash algorithm,
like **SHA-256** or **SHA-512**.
The practical guide with [`utils.hash(){:ts}`](./apis/utils#hash) is explained just in the next section.
</Callout>

<Callout>
**`recordRemoval.keepOnlyLatest` of [`LocalFileStore`](./apis/core#localfilestore)** <br/>
By default, you're using [`localFileStore`](./apis/core#localfilestore) as a *'Store Connector'*.
[`localFileStore`](./apis/core#localfilestore) stores records into the local file *`.haetae/store.json`*.
The option `recordRemoval.keepOnlyLatest{:ts}` is `true{:ts}` by default.
So only the single lastest *Record*s per *Env* per *Command* exist in the store file.
This is sensible when you only need the latest *Record*.
To utilize further past *Records*, you can set the option `false{:ts}`.
Changing or configuring *'Store Connector'* is guided from the [Custom Store](#custom-store) section.
</Callout>

5 Records are found in total.
These are what we've done in this article so far.
**Each of these is the last history of Records executed in each `env` respectively.**
For example, the command `myTest` was executed with `env: {}` on several commits,
and `1d17a2f` is the last commit.

### Custom Record Data

Configuration files for your application is a good example showing the usefulness of Record Data.
I mean a config file not for Haetae, but for your project itself.
To say, dotenv (*`.env`*), .yaml, .properties, .json, etc.

Usually, an application config file satisfies these 2 conditions.

1. It's not explicitly imported (e.g. `import`, `require()`) in the source code. Rather, the source code 'reads' it on runtime.
---> `additionalGraph` or `env` are useful.
2. It's ignored by git. ---> *'Record Data'* is useful.

Let's see how it works, with a simple example project using *`.env`* as the application config.

<Callout>
**dotenv** <br/>
*`.env`* is a configuration file for environment variables, and NOT related to Haetae's `env` at all.
</Callout>

```fish copy filename="Your Project"
your-project
‚îú‚îÄ‚îÄ .env # <--- dotenv file
‚îú‚îÄ‚îÄ .gitignore # <--- ignores '.env' file
‚îú‚îÄ‚îÄ haetae.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ utils.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logic.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ test
    ‚îú‚îÄ‚îÄ utils.test.js
    ‚îú‚îÄ‚îÄ logic.test.js
    ‚îî‚îÄ‚îÄ index.test.js
```

*`src/config.js`* reads the file *`.env`*, by a library [dotenv](https://www.npmjs.com/package/dotenv) for example.

```js copy filename="src/config.js"
import { config } from 'dotenv'

config()

export default {
  port: process.env.PORT,
  secretKey: process.env.SECRET_KEY,
}
```

Let's assume *`logic.js`* gets the value of environment variables through *`config.js`*, not directly reading from *`.env`* or `process.env{:ts}`.
The explicit source code dependency graph is like this.

<Image src="/getting-started/dependency-graph-with-dotenv.svg" alt="Dependency graph"/>

Let Haetae think *`config.js`* depends on *`.env`*.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/git#changedfiles',
  '.graph': './apis/utils#graph',
  '.dependOn': './apis/javascript#dependon',
}}>
```js copy filename="haetae.config.js" {12-13,}
import { $, configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        const additionalGraph = await utils.graph({
          edges: [
            {
              dependents: ['src/config.js'],
              dependencies: ['.env'],
            },
          ],
        })
        const affectedTestFiles = await js.dependOn({
          dependents: ['**/*.test.js'],
          dependencies: changedFiles,
          additionalGraph,
        })
        if (affectedTestFiles.length) {
          await $`pnpm jest ${affectedTestFiles}`
        }
      },
    },
  },
})
```
</TokenLinkCode>

Then the implicit dependency graph becomes explicit.

<Image src="/getting-started/dependency-graph-with-dotenv-focus.svg" alt="Dependency graph with .env"/>

But that's not enough, because *`.env`* is ignored by git.
[`git.changedFiles(){:ts}`](./apis/git#changedfiles) cannot detect if *`.env`* changed or not.

Let's use *'Record Data'* to solve this problem.
Add these into the config file like this.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/git#changedfiles',
  '.getRecord': './apis/core#getrecord',
  '.graph': './apis/utils#graph',
  '.dependOn': './apis/javascript#dependon',
  '.hash': './apis/utils#hash',
}}>
```js copy filename="haetae.config.js" {7,9-13,31-33}
import { $, configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async ({ store }) => {
        const changedFiles = await git.changedFiles()
        const previousRecord = await store.getRecord()
        const dotenvHash = await utils.hash(['.env'])
        if (previousRecord?.data?.dotenv !== dotenvHash) {
          changedFiles.push('.env')
        }
        const additionalGraph = await utils.graph({
          edges: [
            {
              dependents: ['src/config.js'],
              dependencies: ['.env'],
            },
          ],
        })
        const affectedTestFiles = await js.dependOn({
          dependents: ['**/*.test.js'],
          dependencies: changedFiles,
          additionalGraph,
        })

        if (affectedTestFiles.length) {
          await $`pnpm jest ${affectedTestFiles}`
        }
        return {
          dotenv: dotenvHash
        }
      },
    },
  },
})
```
</TokenLinkCode>

Now, **we return an object** from `myTest.run{:ts}`.
Let's execute it.

```fish copy filename="Terminal" {13}
$ haetae myTest

‚úî  success   Command myTest is successfully executed.

‚é° üïó time: 2023 Jun 08 09:23:07 Asia/Seoul (timestamp: 1686183787453)
‚éú üå± env: {}
‚éú #Ô∏è‚É£ envHash: bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f
‚éú üíæ data:
‚éú      "@haetae/git":
‚éú        commit: ac127da6531efa487b8ee35451f24a70dc58aeea
‚éú        branch: main
‚éú        specVersion: 1
‚é£      dotenv: 7f39224e335994886c26ba8c241fcbe1d474aadaa2bd0a8e842983b098cea894
```

Do you see the last line?
The value we returned from `myTest.run{:ts}` is recorded in the store file, as part of *Record Data*.

<Callout>
  **Hash confidential** <br/>
  [`utils.hash(){:ts}`](./apis/utils#hash) is good for secrets like a dotenv file.
  By default, it hashes by SHA-256, and you can simply change the cryptographic hash algorithm by its options, like to SHA-512 for example.
  Thus, you do not need to worry about if the store file is leaked.
</Callout>

This time, *`.env`* was treated as a changed file, as the key `dotenv` did not exist from `previousRecord`.

```js copy filename="haetae.config.js"
// Other content is omitted for brevity
if (previousRecord?.data?.dotenv !== dotenvHash) {
  changedFiles.push('.env')
}
```

Therefore, *`index.test.js`* and *`logic.test.js`*, which transitively depend on *`.env`*, are executed.

If you run Haetae again immediately,

```fish copy filename="Terminal" {12}
haetae myTest
```

This time, no test is executed, as nothing is considered changed. *`.env`* is treated as not changed, thanks to the *Record Data*.

From now on, though the file *`.env`* is ignored by git, changes to it are recorded by custom *Record Data*.
So it can be used in incremental tasks.

### Reserved Record Data

We can enhance the workflow further.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  '.glob': './apis/utils#glob',
  '.graph': './apis/utils#graph',
  '.dependOn': './apis/javascript#dependon',
}}>
```js copy filename="haetae.config.js" {9-10,28}
import { $, configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        const changedFilesByHash = await utils.changedFiles(['.env'])
        changedFiles.push(...changedFilesByHash)
        const additionalGraph = await utils.graph({
          edges: [
            {
              dependents: ['src/config.js'],
              dependencies: ['.env'],
            },
          ],
        })
        const affectedTestFiles = await js.dependOn({
          dependents: ['**/*.test.js'],
          dependencies: changedFiles,
          additionalGraph,
        })

        if (affectedTestFiles.length) {
          await $`pnpm jest ${affectedTestFiles}`
        }
        // No return value
      },
    },
  },
})
```
</TokenLinkCode>

We return nothing here.<br/>
We do not calculate hash by ourselves.<br/>
But this has the same effect as what we've done in the previous section.

```fish copy filename="Terminal" {13-16}
$ haetae myTest

‚úî  success   Command myTest is successfully executed.

‚é° üïó time: 2023 Jun 11 00:27:40 Asia/Seoul (timestamp: 1686410860187)
‚éú üå± env: {}
‚éú #Ô∏è‚É£ envHash: bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f
‚éú üíæ data:
‚éú      "@haetae/git":
‚éú        commit: 018dd7e0c65c3a9d405485df7949ef75ff96e757
‚éú        branch: main
‚éú        specVersion: 1
‚éú      "@haetae/utils":
‚éú        files:
‚éú          .env: 7f39224e335994886c26ba8c241fcbe1d474aadaa2bd0a8e842983b098cea894
‚é£        specVersion: 1
```

You can see the hash of *`.env`* is recorded.
[`utils.changedFiles{:ts}`](./apis/utils#changedfiles) automatically writes hash in *Record Data*,
and compares the current hash with the previous one.

How is this possible?
There's a concept of *Reseved Record Data*.
If you call [`core.reserveRecordData{:ts}`](./apis/core#reserverecorddata),
you can 'reserve' *Record Data* without directly returning custom *Record Data* from the command's `run` function.
[`git.changedFiles{:ts}`](./apis/git#changedfiles)
and [`utils.changedFiles{:ts}`](./apis/utils#changedfiles)
call [`core.reserveRecordData{:ts}`](./apis/core#reserverecorddata) internally.

This mechanism can be especially useful for sharable generic features, like a 3rd-party library for Haetae.
For that, it's important to avoid naming collision.
*Record Data* can have arbitrary fields.
So Haetae uses **a package name as a namespace by convention.**
`'@haetae/git'{:ts}` and `'@haetae/utils'{:ts}` keys in *Record Data* are namespaces to avoid such a collision.

<Callout>
**Multiple Reserved Record Data** <br/>
All *Reserved Record Data* are saved in the list [`core.reservedRecordDataList{:ts}`](./apis/core#reservedrecorddatalist).
The list is to be merged by [`deepmerge`](https://www.npmjs.com/package/deepmerge).
</Callout>

[`utils.changedFiles{:ts}`](./apis/utils#changedfiles) is more useful for multiple files.
Let's say you have multiple dotenv files per environment, unlike the previous assumption.
For example, *`.env.local`*, *`.env.development`*, and *`.env.staging`* are targets to test.
Now, *`config.js`* reads *`.env.${process.env.ENV}{:ts}`*,
where `$ENV` is an indicater of environment: `'local'{:ts}`, `'development'{:ts}` or `'staging'{:ts}`.

Then we can modify the config file like this.

<TokenLinkCode tokens={{
  '$': './apis/haetae#dollar',
  'configure': './apis/haetae#configure',
  '.graph': './apis/utils#graph',
  '.dependOn': './apis/javascript#dependon',
}}>
```js copy filename="haetae.config.js" {9-14,20} showLineNumbers
import { $, configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        const changedFilesByHash = await utils.changedFiles(
          ['.env.*'], // or explicit glob pattern ['.env.{local,development,staging}']
          {
            renew: [`.env.${process.env.ENV}`],
          },
        )
        changedFiles.push(...changedFilesByHash)
        const additionalGraph = await utils.graph({
          edges: [
            {
              dependents: ['src/config.js'],
              dependencies: [`.env.${process.env.ENV}`],
            },
          ],
        })
        const affectedTestFiles = await js.dependOn({
          dependents: ['**/*.test.js'],
          dependencies: changedFiles,
          additionalGraph,
        })

        if (affectedTestFiles.length) {
          await $`pnpm jest ${affectedTestFiles}`
        }
      },
    },
  },
})
```
</TokenLinkCode>

[`renew`](./apis/utils#changedfiles) is a list of files (or glob pattern)
that will be renewed (if changed) by their current hash.
By default, `renew` is equal to all files(`['env.*']{:ts}`) we gave as the argument.
In our config, by limiting it to `.env.${process.env.ENV}{:ts}`, you only renew the single dotenv file.

Let's say currently `$ENV` is `'local'`.
Obviously, *`.env.local`*, *`.env.development`*, and *`.env.staging`* are compared to the previous hashes.
If changes are detected, included in the result array.

But regardless of it, *`.env.development`*, and *`.env.staging`* are not renewed in the new Record Data.
Their previous hashes will be written in the new Record instead of current hashes.

This behavior can be good for our test in many scenarios.

For instance, you may modify *`.env.development`* when `$ENV` is `'local'`.
As it's not in `renew` list, the hash of *`.env.development`* is not updated.
When later `$ENV` becomes `'development'`, [`utils.changedFiles{:ts}`](./apis/utils#changedfiles)
would still think *`.env.development`* is a changed file,
as the current hash and previously recorded hash are different.
This makes sure test files are to be executed when `$ENV` becomes `'development'`.
**[`renew`](./apis/utils#changedfiles) exists for the discrepancy between
when the physical change actually happens and when the detection of the change is needed.**

[`utils.changedFiles{:ts}`](./apis/utils#changedfiles) has many more options,
and acts in a sophisticated way.

For example, by an option `keepRemovedFiles`, which is not introduced above,
you can handle cases like when not all of the files might exist on the filesystem at the same time
and only a few of them are dynamically used in incremental tasks.
For instance, a CI workflow might have access to only *`.env.development`* at a certain time,
while it might have access to only *`.env.staging`* at another time.
And you may still want the incremental history not separated but shared between the two cases.
That's where `keepRemovedFiles` comes in.

[`utils.changedFiles{:ts}`](./apis/utils#changedfiles) is not covered thoroughly here.
Check out the API docs for more detail.

There's one more thing to take care of [`utils.changedFiles{:ts}`](./apis/utils#changedfiles).
You should NOT give a dynamic files argument to it.
Otherwise, a file would be treated as changed every time the dynamic argument changes.

<TokenLinkCode tokens={{
  '.changedFiles': './apis/utils#changedfiles',
}}>
```js copy filename="haetae.config.js" {9-13,19} showLineNumbers
// Other content is omitted for brevity
const changedFilesByHash = await utils.changedFiles(
  [`.env.${process.env.ENV}`] // <--- Anti-pattern
)
```
</TokenLinkCode>

The snippet above lets only a single file to be recorded.
So, if `$ENV` is changed, the previous file is no longer recorded.
This has no safety problem, but reduces incrementality.

Therefore you should list all of the candidates, like `['.env.*']{:ts}`.

## Root Env and Root Record Data

Haetae has a concept of *'Root Env'* (type: [`core.RootEnv{:ts}`](./apis/core#rootenv))
and *'Root Record Data'* (type: [`core.RootRecordData{:ts}`](./apis/core#rootrecorddata)).
They are [decorater](https://en.wikipedia.org/wiki/Decorator_pattern)-like transformers
for the return value of `env` and `run` of every command.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
}}>
```js copy filename="haetae.config.js" {4-6, 9}
import { configure } from 'haetae'

export default configure({
  recordData: async (data) => ({ // <--- 'Root Record Data'
    hello: data.hello.toUpperCase(),
  }),
  commands: {
    myGreeting: {
      run: () => ({ hello: 'world' }),
    },
  },
})
```
</TokenLinkCode>


```fish copy filename="Terminal" {9}
$ haetae myGreeting

‚úî  success   Command myGreeting is successfully executed.

‚é° üïó time: 2023 Jun 14 15:49:52 Asia/Seoul (timestamp: 1686725392672)
‚éú üå± env: {}
‚éú #Ô∏è‚É£ envHash: bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f
‚éú üíæ data:
‚é£      hello: WORLD # <--- capitalized
```

### Hashing *`haetae.config.js`* example

Let's get into a more practical example.<br/>
You may want the config file's hash to be automatically recorded into every command's `env`.
By *Root Env*, it's done in a single place.
You don't have to duplicate the code in every command's `env`.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  '.hash': './apis/utils#hash',
}}>
```js copy filename="haetae.config.js" {5-9}
import * as url from 'node:url'
import { configure, utils } from 'haetae'

export default configure({
  env: async (env) => ({ // <--- 'Root Env'
    ...env,
    // Equals to => await utils.hash(['haetae.config.js']),
    haetaeConfig: await utils.hash([url.fileURLToPath(import.meta.url)]),
  }),
  commands: {
    myGreeting: {
      env: {
        NODE_ENV: process.env.NODE_ENV
      },
      run: () => { /* ... */ }
    },
  },
})
```
</TokenLinkCode>

```fish copy filename="Terminal" {7}
$ haetae myGreeting --env

‚úî  success   Current environment is successfully evaluated for the command myGreeting

‚é° env:
‚éú   NODE_ENV: development
‚éú   haetaeConfig: f7c12d5131846a5db496b87cda59d3e07766ed1bde8ed159538e85f42f3a8dae
‚é£ envHash: e9422335258f9338b7205d11aafdb329bb008f7a
```

By the way, you can go even thoroughly.
[`js.deps{:ts}`](./apis/javascript#deps) lists every direct and transitive dependency.

The snippet below calculates a hash of the config file and its dependencies.
For example, if you import *`a.js`* into *`haetae.config.js`*, and *`a.js`* depends on *`b.js`*,
then the hash is calculated against the three files: *`haetae.config.js`*, *`a.js`*, and *`b.js`*.
When hashing multiple files, a [single-depth sorted Merkle Tree](./apis/utils#hash) is used.

<TokenLinkCode tokens={{
  '.hash': './apis/utils#hash',
  '.deps': './apis/javascript#deps',
}}>
```js copy filename="haetae.config.js" {4}
// Other content is omitted for brevity
haetaeConfig: await utils.hash(
  // More strict than [url.fileURLToPath(import.meta.url)]
  await js.deps({ entrypoint: url.fileURLToPath(import.meta.url) }),
),
```
</TokenLinkCode>

### Propagation

A dependency graph between *Root Env*, *Root Run*, *Command*'s *Run* and *Command*'s *Env* is like this.

<Image src="/getting-started/root-env-root-run-deps-graph.svg" alt="Dependeny graph of 'Root Run' and 'Root Env'"/>

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
}}>
```js copy filename="haetae.config.js"
import assert from 'node:assert/strict'
import { configure } from 'haetae'

export default configure({
  env: async (env) => {
    // Env from each command
    assert(env.hello === 'world')
    return {
      ...env,
      hi: 'there',
    }
  },
  recordData: async (data, { env }) => {
    // Eenv from RootEnv
    assert(env.hi === 'there')
    assert(env.hello === 'world')
    // ...
  },
  commands: {
    myCommand: {
      env: { hello: 'world' },,
      run: async ({ env }) => {
        assert(env.hello === 'world')
        // ...
      }
    },
  },
})
```
</TokenLinkCode>



## Custom Store

We've been using a local file *`.haetae/store.json`* as a store.
It's a good default choice.
But other kind of stores can be used as well.

For instance, you may want to persist *Record*s into a database, or object storage like AWS S3.
Or maybe you can operate a dedicated API server.

By implementing [`core.StoreConnector{:ts}`](./apis/core#storeconnector) interface, you can customize the store.

<TokenLinkCode tokens={{
  'AddRecord': './apis/core#addrecord',
  'GetRecord': './apis/core#getrecord',
}}>
```ts
interface StoreConnector {
  addRecord: AddRecord
  getRecord: GetRecord
}
```
</TokenLinkCode>

Haetae calls `addRecord` after a command is successfully executed.

On the other hand, `getRecord` is called when Haetae needs to know the latest previous *Record* of a command per *Env*.
For example,
[`-r, --record{:ts}`](./cli#-r---record),
[`-d, --record-data{:ts}`](./cli#-d---record-data),
[`git.changedFiles(){:ts}`](./apis/git#changedfiles),
[`utils.changedFiles(){:ts}`](./apis/utils#changedfiles),
and etc use `getRecord` internally.

The default `StoreConnector` implementation is [`core.localFileStore(){:ts}`](./apis/core#localfilestore-1),
which stores *Record*s into *`.haetae/store.json`*.
You can configure its behavior by passing custom [`LocalFileStoreOptions`](./apis/core#localfilestoreoptions).

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  '.localFileStore': './apis/core#localfilestore',

}}>
```ts filename="haetae.config.ts" {5-13}
import { configure, core } from 'haetae'

export default configure({
  commands: { /* ... */ },
  // Default `StoreConnector`
  store: core.localFileStore(
    // You can pass custom `LocalFileStoreOptions`
    filename: '.haetae/store.json'
    recordRemoval: {
      keepOnlyLatest: true,
      // and more ...
    }
  ),
})
```
</TokenLinkCode>

Or let's implement a custom `StoreConnector` that utilizes a RDB through SQL.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  'AddRecordOptions': './apis/core#addrecordoptions',
  'GetRecordOptions': './apis/core#getrecordoptions',
}}>
```ts filename="haetae.config.ts"
import { configure, core } from 'haetae'
import db from 'your-database'

export default configure({
  commands: { /* ... */ },
  store: {
    // Typescript is used to help you see function signatures
    async addRecord({ command, record }: core.AddRecordOptions) {
      await db.sql`
      INSERT INTO record VALUES
      (${command}, ${record.time}, ${record.envHash}, ${record.env}, ${record.data});`
    },
    async getRecord({ command, envHash }: core.GetRecordOptions = {}) {
      const previousRecord = await db.sql`
      SELECT * FROM record
      WHERE command = ${command}
      AND envHash = ${envHash}
      ORDER BY time DESC
      LIMIT 1;`

      // It's allowed to be `undefined` when no previous Record exists
      return previousRecord
    },
  },
})
```
</TokenLinkCode>

You can extend `StoreConnector` interface.
Add any custom properties or functions you want.

The `store` object is accessible from everywhere as well.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
}}>
```js copy filename="haetae.config.ts" {5,6,8,9,20-22}
import { configure } from 'haetae'

export default configure({
  commands: {
    env: async (env, { store }) => { /* ... */ },
    recordData: async (data, { store }) => { /* ... */ },
    myCommand: {
      env: async ({ store }) => { /* ... */ },
      run: async ({ store }) => {
        // const previousRecord = await store.getRecord()
        // const previousRecords = await store.getRecords()
        // await store.deleteRecord(/* ... */)
        // ... any custom store logic you want
      },
    },
  },
  store: {
    async addRecord(options) { /* ... */ },
    async getRecord(options) { /* ... */ },
    // Extending the `StoreConnector` interface by custom functions
    async getRecords(options) { /* ... */ },
    async deleteRecord(options) { /* ... */ },
  },
})
```
</TokenLinkCode>
